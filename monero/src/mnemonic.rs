use core::str;
use std::fmt;

use anyhow::anyhow;
use curve25519_dalek::scalar::Scalar;
use rand::{thread_rng, Rng};
use walletd_mnemonic_model::{MnemonicHandler, Seed};

use crate::mnemonic_type::BITS_IN_BYTES;
use crate::{Language, MnemonicType, WordList};

/// The primary type in this crate, most tasks require creating or using one.
///
/// To create a *new* [`Mnemonic`][Mnemonic] from a randomly generated key, call
/// [`Mnemonic::new()`][Mnemonic::new()].
///
/// To get a [`Mnemonic`][Mnemonic] instance for an existing mnemonic phrase,
/// including those generated by other software or hardware wallets, use
/// [`Mnemonic::from_phrase()`][Mnemonic::from_phrase()].
///
/// You can get the HD wallet [`Seed`][Seed] from a [`Mnemonic`][Mnemonic] by
/// calling [`Seed::new()`][Seed::new()]. From there you can either get the raw
/// byte value with [`Seed::as_bytes()`][Seed::as_bytes()], or the hex
/// representation using Rust formatting: `format!("{:X}", seed)`.
///
/// You can also get the original entropy value back from a
/// [`Mnemonic`][Mnemonic] with [`Mnemonic::entropy()`][Mnemonic::entropy()],
/// but beware that the entropy value is **not the same thing** as an HD wallet
/// seed, and should *never* be used that way.
///
/// [Mnemonic]: ./mnemonic/struct.Mnemonic.html
/// [Mnemonic::new()]: ./mnemonic/struct.Mnemonic.html#method.new
/// [Mnemonic::from_phrase()]: ./mnemonic/struct.Mnemonic.html#method.from_phrase
/// [Mnemonic::entropy()]: ./mnemonic/struct.Mnemonic.html#method.entropy
/// [Seed]: ./seed/struct.Seed.html
/// [Seed::new()]: ./seed/struct.Seed.html#method.new
/// [Seed::as_bytes()]: ./seed/struct.Seed.html#method.as_bytes
#[derive(Debug, Clone)]
pub struct Mnemonic {
    phrase: String,
    lang: Language,
    seed: Seed,
    mnemonic_type: MnemonicType,
}

impl fmt::Display for Mnemonic {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        writeln!(fmt, "Language: {}", self.lang)?;
        writeln!(fmt, " Mnemonic Phrase: {}", &self.phrase)?;
        writeln!(fmt, " Seed hex: {}", self.seed)?;
        writeln!(fmt, " Mnemonic Type: {}", self.mnemonic_type)?;
        Ok(())
    }
}

impl MnemonicHandler for Mnemonic {
    type LanguageHandler = Language;
    type MnemonicStyle = Mnemonic;
    type MnemonicTypeSpec = MnemonicType;

    /// Generates a new mnemonic given the language, length of mnemonic, and
    /// optional passphrase
    fn new(language: Language, mnemonic_type: MnemonicType, _passphrase: Option<&str>) -> Mnemonic {
        let wordlist = WordList::new(language);

        const DEFAULT_LENGTH: usize = 32;
        let random_bytes: [u8; DEFAULT_LENGTH] =
            Scalar::from_bytes_mod_order(thread_rng().gen()).to_bytes();

        let bytes_length = mnemonic_type.entropy_bits() / BITS_IN_BYTES;
        let entropy_bytes = random_bytes[..bytes_length].to_vec();

        let mnemonic_phrase = Self::bytes_to_words(&entropy_bytes, &wordlist)
            .expect("entropy bytes should have a length greater than 0 and divisible by 4");

        let seed = Seed::new(entropy_bytes);

        Mnemonic {
            phrase: mnemonic_phrase,
            lang: language,
            seed,
            mnemonic_type,
        }
    }

    /// Creates a mnemonic object given a mnemonic_phrase, language and an
    /// optional passphrase
    fn from_phrase(
        language: Language,
        mnemonic_phrase: &str,
        _passphrase: Option<&str>,
    ) -> Result<Mnemonic, anyhow::Error> {
        let mnemonic_type = MnemonicType::from_phrase(mnemonic_phrase)?;

        let seed = Seed::new(Self::words_to_bytes(
            language,
            mnemonic_phrase,
            mnemonic_type,
        )?);

        Ok(Mnemonic {
            phrase: mnemonic_phrase.to_string(),
            lang: language,
            seed,
            mnemonic_type,
        })
    }

    /// Provides the Seed object
    fn to_seed(&self) -> Seed {
        self.seed.clone()
    }

    /// Mnemonic from phrase while detecting the language (language is not
    /// specified by the user but can discern the language from the phrase
    /// given)
    fn detect_language(
        mnemonic_phrase: &str,
        passphrase: Option<&str>,
    ) -> Result<Mnemonic, anyhow::Error> {
        let phrase: Vec<&str> = mnemonic_phrase.split_whitespace().collect();
        let language = WordList::detect_language(phrase)?;
        Mnemonic::from_phrase(language, mnemonic_phrase, passphrase)
    }

    /// Gets the phrase
    fn phrase(&self) -> String {
        self.phrase.clone()
    }

    /// Gets the lang field data
    fn language(&self) -> Language {
        self.lang
    }

    /// Gets the mnemonic_type data
    fn mnemonic_type(&self) -> MnemonicType {
        self.mnemonic_type
    }
}

impl Mnemonic {
    fn bytes_to_words(
        entropy_bytes: &Vec<u8>,
        wordlist_info: &WordList,
    ) -> Result<String, anyhow::Error> {
        let wordlist = &wordlist_info.inner();
        if entropy_bytes.len() % 4 != 0 || entropy_bytes.is_empty() {
            return Err(anyhow!(
                "Length of secret_bytes must be greater than 0 and divisible by 4"
            ));
        }

        let list_len = wordlist.len() as u32;
        // Going to map 4 bytes to 3 words
        // First, each chunk of 4 bytes gets converted to a u32 number, using little
        // endian representation
        let inputs = entropy_bytes
            .chunks(4)
            .map(|chunk| {
                let mut input: [u8; 4] = [0u8; 4];
                input.copy_from_slice(chunk);

                u32::from_le_bytes(input)
            })
            .collect::<Vec<u32>>();

        // Next, three words are generated from each of the 4 byte chunks, using the u32
        // numbers generated Indices are calculated to represent each word in
        // the mnemonic phrase in reference to the wordlist
        let mut phrase: Vec<&str> = vec![];
        for index in inputs {
            let w1 = index % list_len;
            let w2 = ((index / list_len) + w1) % list_len;
            let w3 = (((index / list_len) / list_len) + w2) % list_len;

            phrase.push(wordlist.get(w1 as usize).unwrap());
            phrase.push(wordlist.get(w2 as usize).unwrap());
            phrase.push(wordlist.get(w3 as usize).unwrap());
        }

        // The last word added to the mnemonic is a checksum word, it will repeat one of
        // the previous words in the phrase
        let checksum_word = wordlist_info.checksum_word(&phrase);
        phrase.push(&checksum_word);
        Ok(phrase.join(" "))
    }

    fn words_to_bytes(
        language: Language,
        mnemonic_phrase: &str,
        mnemonic_type: MnemonicType,
    ) -> Result<Vec<u8>, anyhow::Error> {
        let wordlist = WordList::new(language);
        let mut phrase: Vec<&str> = mnemonic_phrase.split(' ').collect();
        let trimmed_word_map = wordlist.trimmed_word_map();
        let prefix_len = wordlist.prefix_length();
        let list_len = wordlist.inner().len();

        // The last word in the phrase is the checksum word
        let checksum = phrase.pop().expect("The mnemonic phrase is missing words");
        // Decode the phrase three words at a time, three words equals 4 bytes or one
        // u32 number
        let mut buffer = vec![];
        for chunk in phrase.chunks(3) {
            let w1 = WordList::get_trimmed_word_index(chunk[0], &trimmed_word_map, prefix_len)?;
            let w2 = WordList::get_trimmed_word_index(chunk[1], &trimmed_word_map, prefix_len)?;
            let w3 = WordList::get_trimmed_word_index(chunk[2], &trimmed_word_map, prefix_len)?;
            let n = list_len;
            let x = w1 + n * (((n - w1) + w2) % n) + n * n * (((n - w2) + w3) % n);

            if x % n != w1 {
                return Err(anyhow!("Invalid mnemonic phrase, cannot be decoded"));
            }
            buffer.extend_from_slice(&u32::to_le_bytes(x as u32));
        }
        // Verify the checksum
        let expected_checksum = wordlist.checksum_word(&phrase);
        let expected = WordList::to_trimmed(&expected_checksum, prefix_len);
        let found = WordList::to_trimmed(checksum, prefix_len);
        if expected != found {
            return Err(anyhow!(
                "The mnemonic phrase has an invalid checksum word, expected {}, found {}",
                expected,
                found
            ));
        }

        match mnemonic_type {
            MnemonicType::Words25 => {
                let mut secret_bytes = [0u8; 32];
                secret_bytes.copy_from_slice(&buffer);
                Ok(secret_bytes.to_vec())
            }
            MnemonicType::Words13 => {
                let mut secret_bytes = [0u8; 32];
                let mut buffer_twice = vec![];
                buffer_twice.extend_from_slice(&buffer);
                buffer_twice.extend_from_slice(&buffer);
                secret_bytes.copy_from_slice(&buffer_twice);
                Ok(secret_bytes.to_vec())
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_print() {
        let phrase: &str = "buzzer eject zeal algebra adept arrow shipped mobile reorder light plus rover fawns fight aphid powder tufts niche plotting acumen equip civilian camp dialect algebra";
        let mnemonic = Mnemonic::from_phrase(Language::English, phrase, None).unwrap();
        assert_eq!(format!("{}", mnemonic), "Language: English\n Mnemonic Phrase: buzzer eject zeal algebra adept arrow shipped mobile reorder light plus rover fawns fight aphid powder tufts niche plotting acumen equip civilian camp dialect algebra\n Seed hex: 340fbfc0b9e33b0d58998f2ccb5f3411fbaac7c2d0f41ab2443eb83f9bf3050e\n Mnemonic Type: 25 words\n");
    }

    #[test]
    fn test_new_13_word() {
        let mnemonic = Mnemonic::new(Language::English, MnemonicType::Words13, None);
        assert_eq!(mnemonic.lang, Language::English);
        let phrase: Vec<&str> = mnemonic.phrase.split(" ").collect();
        let word_count = phrase.len();
        assert_eq!(word_count, 13);
    }

    #[test]
    fn test_new_25_word() {
        let mnemonic = Mnemonic::new(Language::English, MnemonicType::Words25, None);
        assert_eq!(mnemonic.lang, Language::English);
        let phrase: Vec<&str> = mnemonic.phrase.split(" ").collect();
        let word_count = phrase.len();
        assert_eq!(word_count, 25);
    }

    #[test]
    fn test_new_13_word_japanese() {
        let mnemonic = Mnemonic::new(Language::Japanese, MnemonicType::Words13, None);
        assert_eq!(mnemonic.lang, Language::Japanese);
        let phrase: Vec<&str> = mnemonic.phrase.split(" ").collect();
        let word_count = phrase.len();
        assert_eq!(word_count, 13);
    }

    #[test]
    fn test_from_phrase() {
        let phrase: &str = "buzzer eject zeal algebra adept arrow shipped mobile reorder light plus rover fawns fight aphid powder tufts niche plotting acumen equip civilian camp dialect algebra";
        let mnemonic = Mnemonic::from_phrase(Language::English, phrase, None).unwrap();
        assert_eq!(mnemonic.phrase, phrase);
        assert_eq!(mnemonic.lang, Language::English);
        // assert_eq!(
        //     mnemonic.seed,
        //     Seed::new(vec![
        //         52, 15, 191, 192, 185, 227, 59, 13, 88, 153, 143, 44, 203, 95, 52,
        // 17, 251, 170,         199, 194, 208, 244, 26, 178, 68, 62, 184, 63,
        // 155, 243, 5, 14     ])
        // );
        assert_eq!(
            mnemonic.to_seed().to_string(),
            "340fbfc0b9e33b0d58998f2ccb5f3411fbaac7c2d0f41ab2443eb83f9bf3050e"
        );
    }

    #[test]
    fn test_detect_language() {
        let phrase: &str = "buzzer eject zeal algebra adept arrow shipped mobile reorder light plus rover fawns fight aphid powder tufts niche plotting acumen equip civilian camp dialect algebra";
        let mnemonic = Mnemonic::detect_language(phrase, None).unwrap();
        assert_eq!(mnemonic.phrase, phrase);
        assert_eq!(mnemonic.lang, Language::English);
        // assert_eq!(
        //     mnemonic.seed,
        //     Seed::new(vec![
        //         52, 15, 191, 192, 185, 227, 59, 13, 88, 153, 143, 44, 203, 95, 52,
        // 17, 251, 170,         199, 194, 208, 244, 26, 178, 68, 62, 184, 63,
        // 155, 243, 5, 14     ])
        // );
        assert_eq!(
            mnemonic.to_seed().to_string(),
            "340fbfc0b9e33b0d58998f2ccb5f3411fbaac7c2d0f41ab2443eb83f9bf3050e"
        );
    }

    #[test]
    fn test_from_phrase_invalid_length() {
        let phrase: &str = "buzzer eject zeal algebra adept arrow shipped mobile reorder light plus rover fawns fight aphid powder tufts niche plotting acumen equip civilian camp dialect";
        assert!(Mnemonic::from_phrase(Language::English, phrase, None).is_err());
    }

    #[test]
    fn test_from_phrase_invalid_word() {
        let phrase: &str = "buzzer eject zeal algebra adept arrow shipped mobile reorder light plus rover fawns fight aphid powder tufts niche plotting acumen equip civilian camp invalid algebra";
        assert!(Mnemonic::from_phrase(Language::English, phrase, None).is_err());
    }

    #[test]
    fn test_from_phrase_empty_phrase() {
        let phrase: &str = "";
        assert!(Mnemonic::from_phrase(Language::English, phrase, None).is_err());
    }
}
