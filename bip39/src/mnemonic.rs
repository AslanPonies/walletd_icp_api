use core::ops::Div;
use core::str;
use std::fmt;

use anyhow::anyhow;
use bitvec::prelude::*;
use curve25519_dalek::scalar::Scalar;
use hmac::Hmac;
use pbkdf2::pbkdf2;
use rand::{thread_rng, Rng};
use sha2::{Digest, Sha256, Sha512};
use walletd_mnemonic_model::{MnemonicHandler, Seed};

use crate::mnemonic_type::ENTROPY_OFFSET;
use crate::{Language, MnemonicType, WordList};

/// The primary type in this crate, most tasks require creating or using one.
///
/// To create a *new* [`Mnemonic`][Mnemonic] from a randomly generated key, call
/// [`Mnemonic::new()`][Mnemonic::new()].
///
/// To get a [`Mnemonic`][Mnemonic] instance for an existing mnemonic phrase,
/// including those generated by other software or hardware wallets, use
/// [`Mnemonic::from_phrase()`][Mnemonic::from_phrase()].
///
/// You can get the HD wallet [`Seed`][Seed] from a [`Mnemonic`][Mnemonic] by
/// calling [`Seed::new()`][Seed::new()]. From there you can either get the raw
/// byte value with [`Seed::as_bytes()`][Seed::as_bytes()], or the hex
/// representation using Rust formatting: `format!("{:X}", seed)`.
///
/// You can also get the original entropy value back from a
/// [`Mnemonic`][Mnemonic] with [`Mnemonic::entropy()`][Mnemonic::entropy()],
/// but beware that the entropy value is **not the same thing** as an HD wallet
/// seed, and should *never* be used that way.
///
/// [Mnemonic]: ./mnemonic/struct.Mnemonic.html
/// [Mnemonic::new()]: ./mnemonic/struct.Mnemonic.html#method.new
/// [Mnemonic::from_phrase()]: ./mnemonic/struct.Mnemonic.html#method.from_phrase
/// [Mnemonic::entropy()]: ./mnemonic/struct.Mnemonic.html#method.entropy
/// [Seed]: ./seed/struct.Seed.html
/// [Seed::new()]: ./seed/struct.Seed.html#method.new
/// [Seed::as_bytes()]: ./seed/struct.Seed.html#method.as_bytes
#[derive(Debug, Clone)]
pub struct Mnemonic {
    phrase: String,
    lang: Language,
    seed: Seed,
    mnemonic_type: MnemonicType,
}

impl fmt::Display for Mnemonic {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        writeln!(fmt, "Language: {}", self.lang)?;
        writeln!(fmt, " Mnemonic Phrase: {}", &self.phrase)?;
        writeln!(fmt, " Seed hex: {}", self.seed)?;
        writeln!(fmt, " Mnemonic Type: {}", self.mnemonic_type)?;
        Ok(())
    }
}

impl Mnemonic {
    fn create_seed(
        language: Language,
        mnemonic_phrase: &String,
        provided_passphrase: Option<&str>,
    ) -> Result<String, anyhow::Error> {
        let mut passphrase = "".to_string();
        if let Some(pass) = provided_passphrase {
            passphrase = pass.to_string();
        }
        // check if mnemonic phrase is valid first
        Self::words_to_bytes(language, mnemonic_phrase)?;

        const PBKDF2_ROUNDS: usize = 2048;
        const PBKDF2_BYTES: usize = 64;
        let mut seed_bytes = vec![0u8; PBKDF2_BYTES];
        let salt = format!("mnemonic{}", passphrase);

        pbkdf2::<Hmac<Sha512>>(
            mnemonic_phrase.as_bytes(),
            salt.as_bytes(),
            PBKDF2_ROUNDS,
            &mut seed_bytes,
        );
        Ok(hex::encode(seed_bytes))
    }
}

impl MnemonicHandler for Mnemonic {
    type LanguageHandler = Language;
    type MnemonicStyle = Mnemonic;
    type MnemonicTypeSpec = MnemonicType;

    /// Generates a new mnemonic given the language, length of mnemonic, and
    /// optional passphrase
    fn new(language: Language, mnemonic_type: MnemonicType, passphrase: Option<&str>) -> Mnemonic {
        let wordlist = WordList::new(language);

        const DEFAULT_LENGTH: usize = 32;
        let random_bytes: [u8; DEFAULT_LENGTH] =
            Scalar::from_bytes_mod_order(thread_rng().gen()).to_bytes();

        let bytes_length = mnemonic_type.entropy_bits() / ENTROPY_OFFSET;
        let entropy_bytes = random_bytes[..bytes_length].to_vec();

        let mnemonic_phrase = Self::bytes_to_words(&entropy_bytes, &wordlist)
            .expect("Failed to generate mnemonic phrase");
        let seed_hex = Self::create_seed(language, &mnemonic_phrase, passphrase)
            .expect("Failed to generate seed");

        let seed = Seed::new(hex::decode(seed_hex).expect("Failed to decode hex to bytes"));

        Mnemonic {
            phrase: mnemonic_phrase,
            lang: language,
            seed,
            mnemonic_type,
        }
    }

    /// Provides the Seed object
    fn to_seed(&self) -> Seed {
        self.seed.clone()
    }

    /// Creates a mnemonic object given a mnemonic_phrase, language and an
    /// optional passphrase
    fn from_phrase(
        language: Language,
        mnemonic_phrase: &str,
        passphrase: Option<&str>,
    ) -> Result<Mnemonic, anyhow::Error> {
        let mnemonic_type = MnemonicType::from_phrase(mnemonic_phrase)?;

        let seed_hex = Self::create_seed(language, &mnemonic_phrase.to_string(), passphrase)?;

        let seed = Seed::new(hex::decode(seed_hex).expect("Failed to decode hex to bytes"));

        Ok(Mnemonic {
            phrase: mnemonic_phrase.to_string(),
            lang: language,
            seed,
            mnemonic_type,
        })
    }

    /// Mnemonic from phrase while detecting the language (language is not
    /// specified by the user but can discern the language from the phrase
    /// given)
    fn detect_language(
        mnemonic_phrase: &str,
        passphrase: Option<&str>,
    ) -> Result<Mnemonic, anyhow::Error> {
        let phrase: Vec<&str> = mnemonic_phrase.split_whitespace().collect();
        let language = WordList::detect_language(phrase)?;
        Mnemonic::from_phrase(language, mnemonic_phrase, passphrase)
    }

    /// Gets the phrase
    fn phrase(&self) -> String {
        self.phrase.clone()
    }

    /// Gets the lang field data
    fn language(&self) -> Language {
        self.lang
    }

    /// Gets the mnemonic_type data
    fn mnemonic_type(&self) -> MnemonicType {
        self.mnemonic_type
    }
}

impl Mnemonic {
    /// Converting entropy bytes to the mnemonic words, given a wordlist
    fn bytes_to_words(
        entropy_bytes: &Vec<u8>,
        wordlist_info: &WordList,
    ) -> Result<String, anyhow::Error> {
        if entropy_bytes.len() % 4 != 0 {
            return Err(anyhow!(
                "Entropy must be a multiple of 4 bytes (32 bits) in length"
            ));
        }
        if (entropy_bytes.len() < 128 / ENTROPY_OFFSET)
            || (entropy_bytes.len() > 256 / ENTROPY_OFFSET)
        {
            return Err(anyhow!(
                "Entropy must be between 128 and 256 bits in length"
            ));
        }

        // Take the sh256 hash of the entropy
        let mut sha256 = Sha256::new();
        sha256.input(entropy_bytes.as_slice());
        let hash = sha256.result();

        // number of words in mnemoic phrase depends on the number of bits in
        // entropy_bytes the number of bits in entropy_bytes (entropy_bytes * 8)
        // + checksum length (1 bit per 32 bits in entropy_bytes) equals the
        // total number of bits which will be a multiple of 33 one word will be
        // specified per 11 bits word_count = (entropy_bytes * 8) +
        // (entropy_bytes/32)/11
        let entropy_bits = entropy_bytes.len() * ENTROPY_OFFSET;
        let word_count = (entropy_bits + (entropy_bits / 32)) / 11;

        // We then take 1 bit of that hash for every 32 bits of entropy, and add it to
        // the end of our entropy.
        let hash_0 = BitVec::<Msb0, u8>::from_element(hash[0]);
        let (checksum, _) = hash_0.split_at(word_count.div(3));
        let mut encoding = BitVec::<Msb0, u8>::from_vec(entropy_bytes.clone());
        encoding.append(&mut checksum.to_vec());

        // Compute the phrase in 11 bit chunks which encode an index into the word list
        let wordlist = &wordlist_info.inner();

        let phrase = encoding
            .chunks(11)
            .map(|index| {
                // Convert a vector of 11 bits into a u11 number.
                let index = index
                    .iter()
                    .enumerate()
                    .map(|(i, &bit)| (bit as u16) * 2u16.pow(10 - i as u32))
                    .sum::<u16>();

                wordlist[index as usize]
            })
            .collect::<Vec<&str>>();
        Ok(phrase.join(" "))
    }

    /// Converts the words of a mnemonic phrase to the bytes representation
    fn words_to_bytes(
        language: Language,
        mnemonic_phrase: &String,
    ) -> Result<Vec<u8>, anyhow::Error> {
        let wordlist = WordList::new(language);
        let phrase: Vec<&str> = mnemonic_phrase.split(' ').collect();
        let word_count = phrase.len();

        // Each word in the mnemonic phrase represents 11 bits
        // A checksum was added to the entropy with a length equal to the number of
        // entropy bits divided by 32 So, the number of original entropy bits
        // can be found: phrase.len() * 11 - (entropy_bits/32) = entropy_bits 32
        // * 11 * phrase.len() - entropy_bits = 32 * entropy_bits
        // 33 * entropy_bits = 32 * 11 * phrase.len()
        // entropy_bits = (32 * 11 * phrase.len()) /  33
        let entropy_bits = (32 * 11 * word_count) / 33;
        let mut entropy: BitVec<Msb0, u8> = BitVec::new();

        for word in phrase {
            let index = wordlist.get_index(word)?;
            let index_u8: [u8; 2] = (index as u16).to_be_bytes();
            let index_slice = &BitVec::from_slice(&index_u8)[5..];
            entropy.append(&mut BitVec::<Msb0, u8>::from_bitslice(index_slice));
        }
        let entropy_bytes = entropy[..entropy_bits].as_slice().to_vec();
        match *mnemonic_phrase == Self::bytes_to_words(&entropy_bytes, &wordlist)? {
            true => Ok(entropy_bytes),
            false => Err(anyhow!(
                "Invalid mnemonic phrase, the checksum word does not match"
            )),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_print() {
        let phrase: &str = "outer ride neither foil glue number place usage ball shed dry point";
        let mnemonic = Mnemonic::from_phrase(Language::English, phrase, None).unwrap();
        assert_eq!(format!("{}", mnemonic), "Language: English\n Mnemonic Phrase: outer ride neither foil glue number place usage ball shed dry point\n Seed hex: a2fd9c0522d84d52ee4c8533dc02d4b69b4df9b6255e1af20c9f1d4d691689f2a38637eb1ec778972bf845c32d5ae83c7536999b5666397ac32021b21e0accee\n Mnemonic Type: 12 words\n");
    }

    #[test]
    fn test_new_12_word() {
        let mnemonic = Mnemonic::new(Language::English, MnemonicType::Words12, None);
        assert_eq!(mnemonic.lang, Language::English);
        let phrase: Vec<&str> = mnemonic.phrase.split(" ").collect();
        let word_count = phrase.len();
        assert_eq!(word_count, 12);
    }

    #[test]
    fn test_new_24_word() {
        let mnemonic = Mnemonic::new(Language::English, MnemonicType::Words24, None);
        assert_eq!(mnemonic.lang, Language::English);
        let phrase: Vec<&str> = mnemonic.phrase.split(" ").collect();
        let word_count = phrase.len();
        assert_eq!(word_count, 24);
    }

    #[test]
    fn test_new_12_word_japanese() {
        let mnemonic = Mnemonic::new(Language::Japanese, MnemonicType::Words12, None);
        assert_eq!(mnemonic.lang, Language::Japanese);
        let phrase: Vec<&str> = mnemonic.phrase.split(" ").collect();
        let word_count = phrase.len();
        assert_eq!(word_count, 12);
    }

    #[test]
    fn test_from_phrase() {
        let phrase: &str = "outer ride neither foil glue number place usage ball shed dry point";
        let mnemonic = Mnemonic::from_phrase(Language::English, phrase, None).unwrap();
        assert_eq!(mnemonic.phrase(), phrase);
        assert_eq!(mnemonic.language(), Language::English);
        assert_eq!(
            mnemonic.to_seed(),
            Seed::new(vec![
                162, 253, 156, 5, 34, 216, 77, 82, 238, 76, 133, 51, 220, 2, 212, 182, 155, 77,
                249, 182, 37, 94, 26, 242, 12, 159, 29, 77, 105, 22, 137, 242, 163, 134, 55, 235,
                30, 199, 120, 151, 43, 248, 69, 195, 45, 90, 232, 60, 117, 54, 153, 155, 86, 102,
                57, 122, 195, 32, 33, 178, 30, 10, 204, 238
            ])
        );
        assert_eq!(mnemonic.to_seed().to_string(), "a2fd9c0522d84d52ee4c8533dc02d4b69b4df9b6255e1af20c9f1d4d691689f2a38637eb1ec778972bf845c32d5ae83c7536999b5666397ac32021b21e0accee");
    }

    #[test]
    fn test_detect_language() {
        let phrase: &str = "outer ride neither foil glue number place usage ball shed dry point";
        let mnemonic = Mnemonic::detect_language(phrase, None).unwrap();
        assert_eq!(mnemonic.phrase(), phrase);
        assert_eq!(mnemonic.language(), Language::English);
        assert_eq!(
            mnemonic.to_seed(),
            Seed::new(vec![
                162, 253, 156, 5, 34, 216, 77, 82, 238, 76, 133, 51, 220, 2, 212, 182, 155, 77,
                249, 182, 37, 94, 26, 242, 12, 159, 29, 77, 105, 22, 137, 242, 163, 134, 55, 235,
                30, 199, 120, 151, 43, 248, 69, 195, 45, 90, 232, 60, 117, 54, 153, 155, 86, 102,
                57, 122, 195, 32, 33, 178, 30, 10, 204, 238
            ])
        );
        assert_eq!(mnemonic.to_seed().to_string(), "a2fd9c0522d84d52ee4c8533dc02d4b69b4df9b6255e1af20c9f1d4d691689f2a38637eb1ec778972bf845c32d5ae83c7536999b5666397ac32021b21e0accee");
    }

    #[test]
    fn test_from_phrase_invalid_length() {
        let phrase: &str = "outer ride neither foil glue number place usage ball shed dry";
        assert!(Mnemonic::from_phrase(Language::English, phrase, None).is_err());
    }

    #[test]
    fn test_from_phrase_invalid_word() {
        let phrase: &str = "outer ride neither foil glue number place usage ball shed dry invalid";
        assert!(Mnemonic::from_phrase(Language::English, phrase, None).is_err());
    }

    #[test]
    fn test_from_phrase_empty_phrase() {
        let phrase: &str = "";
        assert!(Mnemonic::from_phrase(Language::English, phrase, None).is_err());
    }
}
